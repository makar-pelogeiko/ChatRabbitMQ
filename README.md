# ChatRabbitMQ
Chat program with RabbitMQ
## Установка и настройка

- скачать иходные файлы и перейти в корневой каталог проекта:
	```
	git clone https://github.com/makar-pelogeiko/ChatRabbitMQ.git
	cd ChatRabbitMQ
	```
- Установить необходимые python пакеты:
	```
	pip3 install -r requirements.txt
	````
## Работа с проектом

- Для запуска проекта наобходимо выполнить команду `python3 main_2.py`.
  - Для вывода на экран текста с описанием параметров наобходимо выполнить команду `python3 main_2.py --help`.
  - Так же поддерживается 2 опциональных аргумента командной строки `python3 main_2.py <ip_address_of_rabbitMQ> <name_of_chat_channel>`.
- Для просмотра подсказки в приложении необходимо ввести команду `$$`.
- Для отправки сообщения в текущий канал необходимо ввести сообщение и нажать клавишу ввода (сообщение не  может начинаться с управляющего символа `$`).
- Для смены канала необходимо ввести команду `$! <имя_канала>`.
- Для просмотра посещенных каналов необходимо ввести команду `$?`.
- Для выхода из приложения необходимо ввести команду `$exit`.

## Логика работы с проектом

- При запуске проекта можно опционально указать ip адрес сервера rabbitMQ и начальный канал для чата при помощи аргументов командной строки.
- Управление приложением делится на 2 части:
  1. Команды.
  2. Создание и отправка сообщений.
  Для раздения этих двух частей функционала используется командный символ `$`. То есть введенный текст интерпретируется как команда, если он начинается с символа `$`, в противном случае введенный текст распознается как сообщение для отправки.
  
  Данное приложение поддерживает 5 команд:
  1. `exit` — выход из приложения
  2. `$` — показать текст подсказкт
  3. `?` — показать посещенные каналы и количество непрочитанных сообщений в них 
  4. `! <channel_name>` — сменить канал, необходим 1 аргумент через пробел - название канала

## Структура проекта
```shell
                main_2.py
                /       \
               /         \
        chat_2.py      commander.py
```
В файле `main_2.py` реализованы 
- обработка аргументов командой строки 
- связь `commander.py` и `chat_2.py`

В файле `chat_2.py` реализован класс, взаимодействия с сервером rabbitMQ.
- Отправка сообщений
- Смена канала
- Менеджмент каналов
- Получение сообщений из всех посещенных каналов
- Получение списка посещенных каналов

Для получения сообщений используются потоки (1 поток на 1 канал).
функция обработки сообщений для всех каналов 1 (`callback`). В ней полученные сообщения отправляются в буфер в соответствии с каналом или на вывод, если сообщение из активного канала.

Для корректности работы с буферами сообщений и выводом на экран используются примитивы синхронизации (по 1 на каждый буфер).

Для отправки открывается новый канал и закрывается после отправки.

При смене канала добавляются необходимые структуры данных, проводится смена актуального канала и проверка буфера сообщений нового актуального канала.

Сообщения предстваляются в виде словаря, где текст сообщения сохраняется по ключу `'text'`, и отправляются в виде json. 

В файле `commander.py` реализован класс, взаимодействия с вводом пользователья.
- разбор ввода
- запуск соответсвующей команды

команды передаются в виде словаря `имя_команды : ссылка на функцию`.

## Логика очередей RabbitMQ
В данном проекте каждый пользователь и каждый канал имеют свои уникальные имена.
Для отправки сообщения любым пользователем в любой канал используется 1 `topic exchange` с именем `topic_log` и параметром<br/>
`routing_key=<user_name>.<channel_name>`.

Каждый пользователь при использовании канала создает очередь с именем вида `<user_name>.<channel_name>` и подключает ее к topic exchange с параметром `routing_key=*.<channel_name>`. 

Таким образом, `topic exchange` пересылает сообщения в очередь всем пользователям, у которых создан канал с таким же именем.

```
   
 u1:: >->-> u1.ch1,msg:"a" ->->->"topic_log" 
                                 /   |     \
                                /    |      \
                               /     |       \
                              /      |        \
                             /       |         \
                            ↓        ↓          x
                           *.ch1    *.ch1      *.ch2
                            ↓        ↓          x
                          u1.ch1   u2.ch1     u2.ch2
                          msg:"a"  msg:"a"  
```

В данном примере есть 3 очереди `u1.ch1, u2.ch1, u2.ch2` и 1 `topic exchange:topic_log` cо связями `*.ch1, *.ch1, *.ch2`.
Исходя из очередей, мы видим 2 канала `ch1 и ch2` и 2 пользователья `u1 и u2`.

Пользователь `u1` Посетил только канал `ch1`, а пользователь `u2` посетил каналы `ch1 и ch2` (это видно исходя из существующих очередей).

На схеме предствлено отправление пользователем `u1` сообщения "a" в канал `ch1` с `routing_key=u1.ch1`.

Мы видим, что сообщения из `topic_log` были отправлены во очереди `u1.ch1 и u2.ch1`. После чего пользователи `u1 и u2` смогут прочитать сообщение и поместить в соответсвующий буфер (пользователь `u1` удалит сообщение, тк оно получено от него самого, это видно из `routing_key`).
